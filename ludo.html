<html>
<head>
<title>Ludo</title>
<style>
  :root { --cell-size: 8vmin; }
  .dice {
    width: 16vmin;
    height: 16vmin;
    border: 3px solid black;
    border-radius: 15px;
    margin: -8vmin auto;
    position: relative;
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    grid-template-rows: repeat(3, 1fr);
    gap: 1vmin;
    transform: translate(1%, 1%);
    cursor: pointer;
    background: white;
    transition: background-color 0.3s ease, transform 0.2s ease;
  }
  .dot {
    width: 3vmin;
    height: 3vmin;
    background: black;
    border-radius: 50%;
    transform: translate(25%, 25%);
  }
  .main-table {
    margin: 0 auto;
    width: 100vmin;
    height: 95vmin;
  }
  table { border-collapse: collapse; table-layout: fixed; width: 100%; height: 100%; }
  table, tr, td { border: 2px solid black; text-align:center; vertical-align: middle; position: relative; overflow: hidden; }
  .shape { position:absolute; top:50%; left:50%; transform: translate(-50%,-50%); }
  .circle { width:40%; aspect-ratio: 1/1; background:white; border-radius:50%; }
  .circle1:hover, .circle2:hover, .circle3:hover, .circle4:hover { transform: translate(-50%,-50%) scale(1.3); transition: 0.1s ease; }
  .circle1 { background: blue; width: 60%; aspect-ratio:1/1; border-radius:50%; border:1px solid #000; }
  .circle2 { background: red; width: 60%; aspect-ratio:1/1; border-radius:50%; border:1px solid #000; }
  .circle3 { background: yellow; width: 60%; aspect-ratio:1/1; border-radius:50%; border:1px solid #000; }
  .circle4 { background: green; width: 60%; aspect-ratio:1/1; border-radius:50%; border:1px solid #000; }
  .star1 { color: grey; font-size: 5vmin; line-height: 1; user-select: none; }
  .star2 { color: black; font-size: 5vmin; line-height: 1; user-select: none; }
  .home-box { width:95%; height:95%; border-radius:50%; }
  #board { position: relative; }
.piece {
  position: absolute;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  transition: left 0.3s ease, top 0.3s ease, transform 0.2s ease, z-index 0.3s ease;
  border-radius: 50%;
  box-shadow: 0 2px 5px rgba(0,0,0,0.2);
  border: 2px solid rgba(255, 255, 255, 0.8);
  will-change: transform, left, top;
}
.piece:not(:only-child) {
  opacity: 0.95;
}
.blue { background: radial-gradient(circle at 30% 30%, #6495ED, #4169E1); }
.red { background: radial-gradient(circle at 30% 30%, #FF6B6B, #DC143C); }
.green { background: radial-gradient(circle at 30% 30%, #98FB98, #32CD32); }
.yellow { background: radial-gradient(circle at 30% 30%, #FFFACD, #FFD700); }
.piece.active-turn {
  animation: pulse-glow 2s infinite;
}
@keyframes pulse-glow {
  0% { box-shadow: 0 0 5px currentColor; }
  50% { box-shadow: 0 0 15px currentColor; }
  100% { box-shadow: 0 0 5px currentColor; }
}
.piece.multiple {
  box-shadow: 0 2px 8px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.3);
}

.piece:hover {
  z-index: 999 !important;
  transform: translate(-50%, -50%) scale(1.2) !important;
  transition: transform 0.2s ease, z-index 0.2s ease !important;
  box-shadow: 0 4px 12px rgba(0,0,0,0.4), inset 0 2px 0 rgba(255,255,255,0.4);
}
</style>
</head>
<body>
  <div id="board">
    <table border="1px solid black" style="width:40vmin;height: 25vmin; top: -15%; left: 3%;position: absolute;">
    <tr><td>
      <img src="player/blueplayer.png" style="width:100%; height:100%; object-fit: contain;user-select: none;"></td>
      <td style="width:30%;height: 50%;" id="finishblue"></td>
    </tr>
  </table>
      <table border="1px solid black" style="width:40vmin;height: 25vmin; top: -15%; right: 3%;position: absolute;">
    <tr> <td style="width:30%;height: 50%;" id="finishred"></td>
      <td>
      <img src="player/redplayer.png" style="width:100%; height:100%; object-fit: contain;user-select: none;"></td>
    </tr>
  </table>
      <table border="1px solid black" style="width:40vmin;height: 25vmin; bottom: 5%; left: 77%;position: absolute;">
    <tr><td style="width:30%;height: 50%;" id="finishgreen"></td>
      <td>
      <img src="player/greenplayer.png" style="width:100%; height:100%; object-fit: contain;user-select: none;"></td>
    </tr>
  </table>
      <table border="1px solid black" style="width:40vmin;height: 25vmin; bottom: 5%; right: 77%;position: absolute;">
    <tr><td>
      <img src="player/yellowplayer.png" style="width:100%; height:100%; object-fit: contain;user-select: none;"></td>
      <td style="width:30%;height:50%;" id="finishyellow"></td>
    </tr>
  </table>
<table class="main-table" style=>
    <tr> <td style="background-color:#ffc18c;" colspan="6" rowspan="6">
      <table class="home-box" style="border:0px;background-color: blue; border-radius: 50%;" align="center">
        <tr style="border: 0px;">
          <td style="border: 0px;">
            <div id="blue1home"  class="shape circle"> 
              <div id="blue1" class="shape circle1" onmouseover="grow(this)" ontouchstart="grow(this)" onmouseout="shrink(this)" ontouchend="shrink(this)">
              </div>
            </div>
          </td>
          <td style="border: 0px;">
            <div id="blue2home" class="shape circle"> 
              <div id="blue2" class="shape circle1" onmouseover="grow(this)" ontouchstart="grow(this)" onmouseout="shrink(this)" ontouchend="shrink(this)">
              </div>
            </div>
          </td>
        </tr>
        <tr style="border: 0px;">
          <td style="border: 0px;">
            <div id="blue3home" class="shape circle"> 
              <div id="blue3" class="shape circle1" onmouseover="grow(this)" ontouchstart="grow(this)" onmouseout="shrink(this)" ontouchend="shrink(this)">
              </div>
            </div>
          </td>
          <td style="border: 0px;">
            <div id="blue4home" class="shape circle"> 
              <div id="blue4" class="shape circle1"onmouseover="grow(this)" ontouchstart="grow(this)" onmouseout="shrink(this)" ontouchend="shrink(this)">
              </div> 
            </div>
          </td>
        </tr>
      </table>
    </td>  <td id="cell-1"></td> <td id="cell-2"></td> <td id=cell-3></td><td style="background-color:#ffc18c;" colspan="6" rowspan="6">
      <table class="home-box" style="border:0px;background-color: red; border-radius: 50%;" align="center">
        <tr style="border: 0px;">
          <td style="border: 0px;">
            <div id="red1home" class="shape circle">
              <div id="red1" class="shape circle2" onmouseover="grow(this)" ontouchstart="grow(this)" onmouseout="shrink(this)" ontouchend="shrink(this)">
              </div>
            </div>
          </td>
          <td style="border: 0px;">
            <div id="red2home" class="shape circle">
              <div id="red2" class="shape circle2" onmouseover="grow(this)" ontouchstart="grow(this)" onmouseout="shrink(this)" ontouchend="shrink(this)">
              </div>
            </div>
          </td>
        </tr>
        <tr style="border: 0px;">
          <td style="border: 0px;">
            <div id="red3home" class="shape circle">
              <div id="red3" class="shape circle2" onmouseover="grow(this)" ontouchstart="grow(this)" onmouseout="shrink(this)" ontouchend="shrink(this)">
              </div>
            </div>
          </td>
          <td style="border: 0px;">
            <div id="red4home" class="shape circle">
              <div id="red4" class="shape circle2" onmouseover="grow(this)" ontouchstart="grow(this)" onmouseout="shrink(this)" ontouchend="shrink(this)">
              </div>
            </div>
          </td>
        </tr>
      </table>
    </td></tr>
    <tr> <td id="cell-4"></td> <td id="cell-5"style="background-color: red;"></td> <td id="cell-6"style="background-color: red;"><div class="shape star1">★</div></td></tr>
    <tr> <td id="cell-7"><div class="shape star2">★</div></td> <td id="cell-8" style="background-color: red;"></td> <td id="cell-9"></td></tr>
    <tr> <td id="cell-10"></td> <td id="cell-11" style="background-color: red;"></td> <td id="cell-12"></td></tr>
    <tr> <td id="cell-13"></td> <td id="cell-14" style="background-color: red;"></td> <td id="cell-15"></td></tr>
    <tr> <td id="cell-16"></td> <td id="cell-17" style="background-color: red;"></td> <td id="cell-18"></td></tr>

    <tr> <td id="cell-19"></td> <td id="cell-20" style="background-color: blue;"><div class="shape star1">★</div></td> <td id="cell-21"></td> <td id="cell-22"></td> <td id="cell-23"></td> <td id="cell-24"></td> 
      
      <td id="finish" colspan="3" rowspan="3">
        <div id="dice-box" class="dice"></div>
      </td>

      <td id="cell-25"></td> <td id="cell-26"></td> <td id="cell-27"></td> <td id="cell-28"><div class="shape star2">★</div></td> <td id="cell-29"></td> <td id="cell-30"></td></tr>
    <tr> <td id="cell-31"></td> <td id="cell-32" style="background-color: blue;"></td> <td id="cell-33" style="background-color: blue;"></td> <td id="cell-34" style="background-color: blue;"></td> <td id="cell-35" style="background-color: blue;"></td> <td id="cell-36" style="background-color: blue;"></td> <td id="cell-37" style="background-color: green;"></td> <td id="cell-38" style="background-color: green;"></td> <td id="cell-39" style="background-color: green;"></td> <td id="cell-40" style="background-color: green;"></td> <td id="cell-41" style="background-color: green;"></td> <td id="cell-42"></td></tr>
    <tr> <td id="cell-43"></td> <td id="cell-44"></td> <td id="cell-45"><div class="shape star2">★</div></td> <td id="cell-46"></td> <td id="cell-47"></td> <td id="cell-48"></td> <td id="cell-49"></td> <td id="cell-50"></td> <td id="cell-51"></td> <td id="cell-52"></td> <td id="cell-53" style="background-color: green;"><div class="shape star1">★</div></td> <td id="cell-54"></td></tr>
    <tr> <td style="background-color:#ffc18c;" colspan="6" rowspan="6">
      <table class="home-box" style="border:0px;background-color: yellow; border-radius: 50%;" align="center">
        <tr style="border: 0px;">
          <td style="border: 0px;">
            <div id="yellow1home" class="shape circle">
              <div id="yellow1" class="shape circle3" onmouseover="grow(this)" ontouchstart="grow(this)" onmouseout="shrink(this)" ontouchend="shrink(this)">
              </div>
            </div>
          </td>
          <td style="border: 0px;">
            <div id="yellow2home" class="shape circle">
              <div id="yellow2" class="shape circle3" onmouseover="grow(this)" ontouchstart="grow(this)" onmouseout="shrink(this)" ontouchend="shrink(this)">
              </div>
            </div>
          </td>
        </tr>
        <tr style="border: 0px;">
          <td style="border: 0px;">
            <div id="yellow3home" class="shape circle">
              <div id="yellow3" class="shape circle3" onmouseover="grow(this)" ontouchstart="grow(this)" onmouseout="shrink(this)" ontouchend="shrink(this)">
              </div>
            </div>
          </td>
          <td style="border: 0px;">
            <div id="yellow4home" class="shape circle">
              <div id="yellow4" class="shape circle3" onmouseover="grow(this)" ontouchstart="grow(this)" onmouseout="shrink(this)" ontouchend="shrink(this)">
              </div>
            </div>
          </td>
        </tr>
      </table></td>  <td id="cell-55"></td> <td id="cell-56" style="background-color: yellow;"></td> <td id="cell-57"></td><td style="background-color:#ffc18c;" colspan="6" rowspan="6">
        <table class="home-box" style="px;border:0px;background-color: green; border-radius: 50%;" align="center">
        <tr  style="border: 0px;">
          <td style="border: 0px;">
            <div id="green1home" class="shape circle">
              <div id="green1" class="shape circle4" onmouseover="grow(this)" ontouchstart="grow(this)" onmouseout="shrink(this)" ontouchend="shrink(this)">
              </div>
            </div>
          </td>
          <td style="border: 0px;">
            <div id="green2home" class="shape circle">
              <div id="green2" class="shape circle4" onmouseover="grow(this)" ontouchstart="grow(this)" onmouseout="shrink(this)" ontouchend="shrink(this)">
              </div>
            </div>
        </td>
        </tr>
        <tr style="border: 0px;">
          <td style="border: 0px;">
            <div id="green3home" class="shape circle">
              <div id="green3" class="shape circle4" onmouseover="grow(this)" ontouchstart="grow(this)" onmouseout="shrink(this)" ontouchend="shrink(this)">
              </div>
            </div>
          </td>
          <td style="border: 0px;">
            <div id="green4home" class="shape circle">
              <div id="green4" class="shape circle4" onmouseover="grow(this)" ontouchstart="grow(this)" onmouseout="shrink(this)" ontouchend="shrink(this)">
              </div>
            </div>
          </td>
        </tr>
      </table>
      </td></tr>
    <tr> <td id="cell-58"></td> <td id="cell-59" style="background-color: yellow;"></td> <td id="cell-60"></td></tr>
    <tr> <td id="cell-61"></td> <td id="cell-62" style="background-color: yellow;"></td> <td id="cell-63"></td></tr>
    <tr> <td id="cell-64"></td> <td id="cell-65" style="background-color: yellow;"></td> <td id="cell-66"><div class="shape star2">★</div></td></tr>
    <tr> <td id="cell-67" style="background-color: yellow;"><div class="shape star1">★</div></td> <td id="cell-68" style="background-color: yellow;"></td> <td id="cell-69"></td></tr>
    <tr> <td id="cell-70"></td> <td id="cell-71"></td> <td id="cell-72"></td></tr>
  </table>
  </div>
  <script>
document.addEventListener("DOMContentLoaded", ()=>{

const players = ["blue","red","green","yellow"];
let currentPlayerIndex = 0;

const playerActive = {
  blue: true,
  red: true,
  green: true,
  yellow: true
};

const consecutiveOnes = {
  blue: 0,
  red: 0,
  green: 0,
  yellow: 0
};

const lastMovedPiece = {
  blue: null,
  red: null,
  green: null,
  yellow: null
};

let justKilled = false;

const safeCells = ["cell-6","cell-7","cell-20","cell-28","cell-45","cell-53","cell-66","cell-67"];

const paths = {
  blue:  [20,21,22,23,24,16,13,10,7,4,1,2,3,6,9,12,15,18,25,26,27,28,29,30,42,54,53,52,51,50,49,57,60,63,66,69,72,71,70,67,64,61,58,55,48,47,46,45,44,43,31,32,33,34,35,36,'finishblue'],
  red:   [6,9,12,15,18,25,26,27,28,29,30,42,54,53,52,51,50,49,57,60,63,66,69,72,71,70,67,64,61,58,55,48,47,46,45,44,43,31,19,20,21,22,23,24,16,13,10,7,4,1,2,5,8,11,14,17,'finishred'],
  green: [53,52,51,50,49,57,60,63,66,69,72,71,70,67,64,61,58,55,48,47,46,45,44,43,31,19,20,21,22,23,24,16,13,10,7,4,1,2,3,6,9,12,15,18,25,26,27,28,29,30,42,41,40,39,38,37,'finishgreen'],
  yellow:[67,64,61,58,55,48,47,46,45,44,43,31,19,20,21,22,23,24,16,13,10,7,4,1,2,3,6,9,12,15,18,25,26,27,28,29,30,42,54,53,52,51,50,49,57,60,63,66,69,72,71,68,65,62,59,56,'finishyellow']
};

const pieces = {};
players.forEach(color => {
  for(let i=1;i<=4;i++){
    const id = color + i;
    pieces[id] = { id, color, posIndex: -1, isMoving: false };
  }
});

const gameState = { diceValue: null };

function checkAllPiecesFinished(color) {
  const colorPieces = Object.values(pieces).filter(p => p.color === color);
  
  const allFinished = colorPieces.every(p => p.posIndex === 'finished');
  
  if (allFinished && playerActive[color]) {
    playerActive[color] = false;
    
    const toggleBtn = document.getElementById(`toggle-${color}`);
    if (toggleBtn) {
      toggleBtn.textContent = "OFF";
      toggleBtn.style.background = "#f44336";
    }
    
    for(let i=1;i<=4;i++){
      const pieceId = color + i;
      const pieceEl = document.getElementById(pieceId);
      if(pieceEl) {
        pieceEl.style.opacity = "0.3";
        pieceEl.style.pointerEvents = "none";
        
        if(pieceEl.parentElement) {
          updatePieceStacking(pieceEl.parentElement);
        }
      }
    }
    
    attachPieceListeners();
    attachHoverEffect();
    
    skipInactivePlayers();
    
    return true;
  }
  
  return false;
}

function determineWinner() {
  const playerScores = {};
  
  players.forEach(color => {
    if (playerActive[color]) {
      const colorPieces = Object.values(pieces).filter(p => p.color === color);
      const finishedCount = colorPieces.filter(p => p.posIndex === 'finished').length;
      playerScores[color] = finishedCount;
    }
  });
  
  let winner = null;
  let maxFinished = -1;
  
  for (const [color, score] of Object.entries(playerScores)) {
    if (score > maxFinished) {
      maxFinished = score;
      winner = color;
    }
  }
  
  return winner ? winner.charAt(0).toUpperCase() + winner.slice(1) : "No winner";
}

let settingsPanel = null;
let settingsToggleBtn = null;
let isSettingsOpen = false;

function createSettingsPanel() {
  settingsToggleBtn = document.createElement("button");
  settingsToggleBtn.id = "settings-toggle";
  settingsToggleBtn.innerHTML = "≡";
  settingsToggleBtn.title = "Player Settings";
  settingsToggleBtn.style.position = "fixed";
  settingsToggleBtn.style.top = "10px";
  settingsToggleBtn.style.left = "10px";
  settingsToggleBtn.style.zIndex = "1000";
  settingsToggleBtn.style.padding = "10px";
  settingsToggleBtn.style.fontSize = "20px";
  settingsToggleBtn.style.background = "#333";
  settingsToggleBtn.style.color = "white";
  settingsToggleBtn.style.border = "2px solid white";
  settingsToggleBtn.style.borderRadius = "5px";
  settingsToggleBtn.style.cursor = "pointer";
  settingsToggleBtn.style.boxShadow = "0 2px 5px rgba(0,0,0,0.3)";
  settingsPanel = document.createElement("div");
  settingsPanel.id = "settings-panel";
  settingsPanel.style.position = "fixed";
  settingsPanel.style.top = "10px";
  settingsPanel.style.left = "10px";
  settingsPanel.style.transform = "translateX(-100%)";
  settingsPanel.style.transition = "transform 0.3s ease";
  settingsPanel.style.zIndex = "999";
  settingsPanel.style.background = "rgba(255, 255, 255, 0.95)";
  settingsPanel.style.border = "2px solid #333";
  settingsPanel.style.borderRadius = "8px";
  settingsPanel.style.padding = "20px";
  settingsPanel.style.boxShadow = "0 4px 12px rgba(0,0,0,0.2)";
  settingsPanel.style.minWidth = "200px";
  const title = document.createElement("h3");
  title.textContent = "Player Settings";
  title.style.marginTop = "0";
  title.style.marginBottom = "15px";
  title.style.color = "#333";
  title.style.textAlign = "center";
  settingsPanel.appendChild(title);
  
  players.forEach(color => {
    const toggleContainer = document.createElement("div");
    toggleContainer.style.display = "flex";
    toggleContainer.style.alignItems = "center";
    toggleContainer.style.justifyContent = "space-between";
    toggleContainer.style.marginBottom = "15px";
    toggleContainer.style.padding = "8px";
    toggleContainer.style.background = "#f5f5f5";
    toggleContainer.style.borderRadius = "5px";
    
    const label = document.createElement("span");
    label.textContent = color.charAt(0).toUpperCase() + color.slice(1);
    label.style.fontWeight = "bold";
    label.style.color = color;
    
    const toggleBtn = document.createElement("button");
    toggleBtn.id = `toggle-${color}`;
    toggleBtn.textContent = playerActive[color] ? "ON" : "OFF";
    toggleBtn.style.padding = "5px 15px";
    toggleBtn.style.border = "none";
    toggleBtn.style.borderRadius = "3px";
    toggleBtn.style.background = playerActive[color] ? "#4CAF50" : "#f44336";
    toggleBtn.style.color = "white";
    toggleBtn.style.cursor = "pointer";
    toggleBtn.style.fontWeight = "bold";
    
    toggleBtn.onclick = () => {
      const colorPieces = Object.values(pieces).filter(p => p.color === color);
      const allFinished = colorPieces.every(p => p.posIndex === 'finished');
      
      if (allFinished) {
        return;
      }
      
      playerActive[color] = !playerActive[color];
      toggleBtn.textContent = playerActive[color] ? "ON" : "OFF";
      toggleBtn.style.background = playerActive[color] ? "#4CAF50" : "#f44336";
      
      for(let i=1;i<=4;i++){
        const pieceId = color + i;
        const pieceEl = document.getElementById(pieceId);
        if(pieceEl) {
          pieceEl.style.opacity = playerActive[color] ? "1" : "0.3";
          pieceEl.style.pointerEvents = playerActive[color] ? "auto" : "none";
          
          if(pieceEl.parentElement) {
            updatePieceStacking(pieceEl.parentElement);
          }
        }
      }
      
      attachPieceListeners();
      attachHoverEffect();
      
      skipInactivePlayers();
      
      closeSettingsPanel();
    };
    
    toggleContainer.appendChild(label);
    toggleContainer.appendChild(toggleBtn);
    settingsPanel.appendChild(toggleContainer);
  });
  
  const closeBtn = document.createElement("button");
  closeBtn.textContent = "Close";
  closeBtn.style.display = "block";
  closeBtn.style.margin = "10px auto 0";
  closeBtn.style.padding = "8px 20px";
  closeBtn.style.background = "#333";
  closeBtn.style.color = "white";
  closeBtn.style.border = "none";
  closeBtn.style.borderRadius = "3px";
  closeBtn.style.cursor = "pointer";
  
  closeBtn.onclick = closeSettingsPanel;
  settingsPanel.appendChild(closeBtn);
  
  document.body.appendChild(settingsToggleBtn);
  document.body.appendChild(settingsPanel);
  
  settingsToggleBtn.addEventListener("click", toggleSettingsPanel);
  
  updatePlayerPiecesVisibility();
}

function toggleSettingsPanel() {
  if(isSettingsOpen) {
    closeSettingsPanel();
  } else {
    openSettingsPanel();
  }
}

function openSettingsPanel() {
  settingsPanel.style.transform = "translateX(0)";
  settingsToggleBtn.style.transform = "translateX(250px)";
  isSettingsOpen = true;
}

function closeSettingsPanel() {
  settingsPanel.style.transform = "translateX(-100%)";
  settingsToggleBtn.style.transform = "translateX(0)";
  isSettingsOpen = false;
}

function updatePlayerPiecesVisibility() {
  players.forEach(color => {
    for(let i=1;i<=4;i++){
      const pieceId = color + i;
      const pieceEl = document.getElementById(pieceId);
      if(pieceEl) {
        pieceEl.style.opacity = playerActive[color] ? "1" : "0.3";
        pieceEl.style.pointerEvents = playerActive[color] ? "auto" : "none";
      }
    }
  });
}

function skipInactivePlayers() {
  let attempts = 0;
  
  while(attempts < players.length) {
    const currentPlayer = players[currentPlayerIndex];
    if(playerActive[currentPlayer]) {
      break;
    }
    currentPlayerIndex = (currentPlayerIndex + 1) % players.length;
    attempts++;
  }
  
  const activePlayers = players.filter(p => playerActive[p]);
  
  if (activePlayers.length === 0) {
    setTimeout(() => {
      const winner = determineWinner();
      alert(`Game Over! ${winner} wins!`);
    }, 500);
    return;
  }
  
  if (activePlayers.length === 1) {
    const winner = activePlayers[0];
    setTimeout(() => {
      alert(`Game Over! ${winner.charAt(0).toUpperCase() + winner.slice(1)} loses! All other players have finished.`);
    }, 500);
  }
  
  updateDiceAppearance();
}

const diceBox = document.getElementById("dice-box");
function getCurrentPlayer(){ 
  let player = players[currentPlayerIndex];
  let attempts = 0;
  while(!playerActive[player] && attempts < players.length) {
    currentPlayerIndex = (currentPlayerIndex + 1) % players.length;
    player = players[currentPlayerIndex];
    attempts++;
  }
  return player; 
}

function updateDiceAppearance(){
  const player = getCurrentPlayer();
  if(diceBox) diceBox.style.backgroundColor = player;
  if(gameState.diceValue === null){
    if(diceBox) diceBox.innerHTML = "";
  } else {
    drawDiceFace(gameState.diceValue);
  }
}

function weightedRoll(){
  const outcomes=[1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6];
  return outcomes[Math.floor(Math.random()*outcomes.length)];
}

function drawDiceFace(num){
  if(!diceBox) return;
  diceBox.innerHTML = "";
  const positions={1:[5],2:[1,9],3:[1,5,9],4:[1,3,7,9],5:[1,3,5,7,9],6:[1,3,4,6,7,9]};
  (positions[num]||[]).forEach(pos=>{
    const dot=document.createElement("div");
    dot.className="dot";
    const row=Math.ceil(pos/3);
    const col=(pos-1)%3+1;
    dot.style.gridArea = `${row} / ${col}`;
    diceBox.appendChild(dot);
  });
}

function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

function awaitTransition(el, timeout = 500){
  return new Promise(resolve=>{
    let timer = setTimeout(()=>{ el.removeEventListener('transitionend', done); resolve(); }, timeout);
    function done(e){
      if(e.propertyName === 'left' || e.propertyName === 'top'){
        clearTimeout(timer);
        el.removeEventListener('transitionend', done);
        resolve();
      }
    }
    el.addEventListener('transitionend', done);
  });
}

function isFinishToken(val){
  return (typeof val === 'string') && val.startsWith('finish');
}

function isTopPiece(pieceId){
  const el = document.getElementById(pieceId);
  if(!el || !el.parentElement) return false;
  
  const children = Array.from(el.parentElement.children).filter(c => {
    if(!c.id || !pieces[c.id]) return false;
    return playerActive[pieces[c.id].color];
  });
  
  if(children.length === 0) return false;
  return children[children.length-1].id === pieceId;
}

function attachHoverEffect(){
  Object.keys(pieces).forEach(pid=>{
    const el = document.getElementById(pid);
    if(!el) return;

    function grow(){
      const p = pieces[pid];
      if(!p) return;
      if(p.color === getCurrentPlayer() && !p.isMoving && isTopPiece(pid) && playerActive[p.color]){
        el.style.transition = "transform 0.18s ease";
        el.style.transform = "translate(-50%,-50%) scale(1.25)";
        el.style.zIndex = 999;
      }
    }
    function shrink(){
      const p = pieces[pid];
      if(!p) return;
      if(!p.isMoving){
        el.style.transition = "transform 0.18s ease";
        el.style.transform = "translate(-50%,-50%) scale(1)";
        el.style.zIndex = "";
      }
    }

    el.onmouseenter = null; el.onmouseleave = null;
    el.addEventListener("mouseenter", grow);
    el.addEventListener("mouseleave", shrink);
    el.addEventListener("touchstart", e=>{ 
      const p = pieces[pid];
      if(p && p.color===getCurrentPlayer() && !p.isMoving && isTopPiece(pid) && playerActive[p.color]){ 
        e.preventDefault(); 
        grow(); 
      } 
    }, {passive:false});
    el.addEventListener("touchend", shrink);
    el.addEventListener("touchcancel", shrink);
  });
}

function attachPieceListeners(){
  Object.keys(pieces).forEach(pid=>{
    const el = document.getElementById(pid);
    if(!el) return;
    el.style.touchAction = "manipulation";
    
    const piece = pieces[pid];
    if(piece && playerActive[piece.color]) {
      el.addEventListener("click", ()=> handlePieceSelection(pid));
      el.addEventListener("touchstart", e=>{ e.preventDefault(); handlePieceSelection(pid); }, {passive:false});
    } else {
      el.removeEventListener("click", handlePieceSelection);
      el.removeEventListener("touchstart", handlePieceSelection);
    }
  });
}

function getCellIdForPath(color,index){
  const val = paths[color][index];
  if(isFinishToken(val)) return val;
  return 'cell-' + val;
}
function getPathCells(color, startIndex, endIndex){
  const path = paths[color];
  const cells = [];
  for(let i=startIndex;i<=endIndex;i++){
    const v = path[i];
    if(isFinishToken(v)) cells.push(v);
    else cells.push('cell-' + v);
  }
  return cells;
}

async function returnPieceHome(pieceId, penalty = false, specificHomeId = null){
  const p = pieces[pieceId];
  if(!p) return;
  
  if(!playerActive[p.color]) {
    console.log(`Cannot return ${pieceId} home - player is inactive`);
    return;
  }
  
  const el = document.getElementById(pieceId);
  if(!el) return;

  let targetHomeEl = null;
  
  if(specificHomeId) {
    targetHomeEl = document.getElementById(specificHomeId);
  }
  
  if(!targetHomeEl) {
    const homeIds = [`${p.color}1home`,`${p.color}2home`,`${p.color}3home`,`${p.color}4home`];
    for(const hid of homeIds){
      const homeEl = document.getElementById(hid);
      if(homeEl && Array.from(homeEl.children).filter(c=>c.id && pieces[c.id]).length === 0){
        targetHomeEl = homeEl;
        break;
      }
    }
  }
  
  if(!targetHomeEl) targetHomeEl = document.getElementById(`${p.color}1home`);
  if(!targetHomeEl) return;
  p.posIndex = -1;
  p.isMoving = true;
  const board = document.getElementById("board");  
  const rect = el.getBoundingClientRect();
  const boardRect = board.getBoundingClientRect();
  const startXPercent = ((rect.left - boardRect.left) / boardRect.width) * 100;
  const startYPercent = ((rect.top - boardRect.top) / boardRect.height) * 100;
  const homeRect = targetHomeEl.getBoundingClientRect();
  const targetXPercent = ((homeRect.left - boardRect.left + homeRect.width/2) / boardRect.width) * 100;
  const targetYPercent = ((homeRect.top - boardRect.top + homeRect.height/2) / boardRect.height) * 100;
  el.style.position = "absolute";
  el.style.left = startXPercent + "%";
  el.style.top = startYPercent + "%";
  el.style.width = rect.width + "px";
  el.style.height = rect.height + "px";
  el.style.transition = "left 400ms ease, top 400ms ease, transform 0.2s ease";
  board.appendChild(el);
  await sleep(10);
  el.style.left = targetXPercent + "%";
  el.style.top  = targetYPercent + "%";
  await awaitTransition(el, 450);
  targetHomeEl.appendChild(el);
  el.style.position = "absolute";
  el.style.width = "";
  el.style.height = "";
  el.style.left = "50%";
  el.style.top = "50%";
  el.style.transform = "translate(-50%,-50%) scale(1)";
  el.style.transition = "";
  updatePieceStacking(targetHomeEl);
  p.isMoving = false;
  if (penalty) {
    consecutiveOnes[p.color] = 0;
  }
}

function updatePieceStacking(cell){
  if(!cell) return;
  const allPieceElements = Array.from(cell.children).filter(c=>c.id && pieces[c.id]);
  const activePieces = allPieceElements.filter(el => {
    const piece = pieces[el.id];
    return piece && playerActive[piece.color];
  });
  const inactivePieces = allPieceElements.filter(el => {
    const piece = pieces[el.id];
    return piece && !playerActive[piece.color];
  });
  
  const totalPieces = allPieceElements.length;
  if(totalPieces === 0) return;
  allPieceElements.forEach(el=>{ 
    el.style.transition = "left 0.3s ease, top 0.3s ease, z-index 0.3s ease";
    el.style.boxShadow = "0 2px 5px rgba(0,0,0,0.2)";
  });

  if(totalPieces === 1){
    const el = allPieceElements[0];
    el.style.position = "absolute";
    el.style.left = "50%";
    el.style.top = "50%";
    el.style.transform = "translate(-50%,-50%) scale(1)";
    el.style.zIndex = 1;
    el.classList.remove('multiple');
    return;
  }

  if (activePieces.length === 2) {
    activePieces[0].style.left = "40%";
    activePieces[0].style.top = "50%";
    activePieces[0].style.transform = "translate(-50%,-50%) scale(0.95)";
    activePieces[0].style.zIndex = 1;
    activePieces[1].style.left = "60%";
    activePieces[1].style.top = "50%";
    activePieces[1].style.transform = "translate(-50%,-50%) scale(0.95)";
    activePieces[1].style.zIndex = 2;
  }
  else if (activePieces.length === 3) {
    activePieces[0].style.left = "50%";
    activePieces[0].style.top = "40%";
    activePieces[0].style.transform = "translate(-50%,-50%) scale(0.9)";
    activePieces[0].style.zIndex = 1;
    activePieces[1].style.left = "35%";
    activePieces[1].style.top = "60%";
    activePieces[1].style.transform = "translate(-50%,-50%) scale(0.9)";
    activePieces[1].style.zIndex = 2;
    activePieces[2].style.left = "65%";
    activePieces[2].style.top = "60%";
    activePieces[2].style.transform = "translate(-50%,-50%) scale(0.9)";
    activePieces[2].style.zIndex = 3;
  }
  else if (activePieces.length === 4) {
    activePieces[0].style.left = "40%";
    activePieces[0].style.top = "40%";
    activePieces[0].style.transform = "translate(-50%,-50%) scale(0.85)";
    activePieces[0].style.zIndex = 1;
    activePieces[1].style.left = "60%";
    activePieces[1].style.top = "40%";
    activePieces[1].style.transform = "translate(-50%,-50%) scale(0.85)";
    activePieces[1].style.zIndex = 2;
    activePieces[2].style.left = "40%";
    activePieces[2].style.top = "60%";
    activePieces[2].style.transform = "translate(-50%,-50%) scale(0.85)";
    activePieces[2].style.zIndex = 3;
    activePieces[3].style.left = "60%";
    activePieces[3].style.top = "60%";
    activePieces[3].style.transform = "translate(-50%,-50%) scale(0.85)";
    activePieces[3].style.zIndex = 4;
  }
  else if (activePieces.length > 4) {
    const cols = Math.ceil(Math.sqrt(activePieces.length));
    const rows = Math.ceil(activePieces.length / cols);
    const cellWidth = 100 / (cols + 1);
    const cellHeight = 100 / (rows + 1);
    const scale = Math.max(0.7, 1 - (activePieces.length * 0.05));
    activePieces.forEach((el, index) => {
      const col = index % cols;
      const row = Math.floor(index / cols);
      const x = (col + 1) * cellWidth;
      const y = (row + 1) * cellHeight;
      el.style.left = `${x}%`;
      el.style.top = `${y}%`;
      el.style.transform = `translate(-50%,-50%) scale(${scale})`;
      el.style.zIndex = index + 1;
    });
  }
  
  if (inactivePieces.length > 0) {
    const scale = 0.8;
    const baseX = 80;
    const baseY = 80;
    inactivePieces.forEach((el, index) => {
      const offsetX = (index % 3) * 8;
      const offsetY = Math.floor(index / 3) * 8;
      el.style.left = `${baseX + offsetX}%`;
      el.style.top = `${baseY + offsetY}%`;
      el.style.transform = `translate(-50%,-50%) scale(${scale})`;
      el.style.zIndex = activePieces.length + index + 10;
      el.style.opacity = "0.5";
    });
  }
  
  allPieceElements.forEach(el => {
    if (totalPieces > 1) {
      el.classList.add('multiple');
    } else {
      el.classList.remove('multiple');
    }
  });
}

async function movePieceAlongPath(pieceId, targetIndex){
  const p = pieces[pieceId];
  const el = document.getElementById(pieceId);
  const board = document.getElementById("board");
  if(!p || !el || !board) return;
  if(p.isMoving) return;
  p.isMoving = true;
  const startIndex = p.posIndex === -1 ? -1 : p.posIndex;
  let endIndex;
  let isFinishing = false;
  if(targetIndex === 'finish'){
    endIndex = paths[p.color].length - 1;
    isFinishing = true;
  } else {
    endIndex = targetIndex;
  }
  const pathCells = getPathCells(p.color, startIndex + 1, endIndex);
  if(pathCells.length === 0){ p.isMoving = false; return; }
  const rect = el.getBoundingClientRect();
  const width = rect.width, height = rect.height;
  const boardRect = board.getBoundingClientRect();
  const startX = rect.left - boardRect.left + board.scrollLeft;
  const startY = rect.top - boardRect.top + board.scrollTop;
  const oldCell = el.parentElement;
  el.style.transition = "left 180ms linear, top 180ms linear";
  el.style.width = width + "px";
  el.style.height = height + "px";
  el.style.position = "absolute";
  el.style.transform = "translate(0,0)";
  el.style.left = startX + "px";
  el.style.top = startY + "px";
  board.appendChild(el);
  await sleep(8);
  for(let i=0;i<pathCells.length;i++){
    const cellId = pathCells[i];
    const cell = document.getElementById(cellId);
    if(!cell) {
      continue;
    }
    const crect = cell.getBoundingClientRect();
    const targetLeft = crect.left - boardRect.left + (cell.offsetWidth/2) - width/2 + board.scrollLeft;
    const targetTop  = crect.top  - boardRect.top  + (cell.offsetHeight/2) - height/2 + board.scrollTop;
    el.style.left = `${targetLeft}px`;
    el.style.top  = `${targetTop}px`;
    await awaitTransition(el, 400);
    await sleep(30);
  }

  let finalCell = null;
  if(isFinishing){
    const finishId = paths[p.color][paths[p.color].length - 1];
    finalCell = document.getElementById(finishId);
    if(!finalCell){
      const finishArea = document.getElementById('finish');
      if(finishArea){
        let finishContainer = document.getElementById(`${p.color}-finished-container`);
        if(!finishContainer){
          finishContainer = document.createElement('div');
          finishContainer.id = `${p.color}-finished-container`;
          finishContainer.style.position = 'relative';
          finishContainer.style.width = '100%';
          finishContainer.style.height = '100%';
          finishArea.appendChild(finishContainer);
        }
        finalCell = finishContainer;
      }
    }
  } else {
    finalCell = document.getElementById(getCellIdForPath(p.color, endIndex));
  }

  if(finalCell){
    finalCell.appendChild(el);
    el.style.position = "absolute";
    el.style.width = "";
    el.style.height = "";
    el.style.left = "50%";
    el.style.top = "50%";
    el.style.transform = "translate(-50%,-50%)";
    el.style.transition = "";
    updatePieceStacking(finalCell);
    if(!isFinishing && !safeCells.includes(finalCell.id)){
      const children = Array.from(finalCell.children).filter(c=>c.id && pieces[c.id]);
      let killCount = 0;
      for(const child of children){
        if(child.id !== pieceId && pieces[child.id] && pieces[child.id].color !== p.color){
          if(playerActive[pieces[child.id].color]) {
            killCount++;
            const pieceNumber = child.id.replace(pieces[child.id].color, '');
            const originalHomeId = `${pieces[child.id].color}${pieceNumber}home`;
            returnPieceHome(child.id, false, originalHomeId);
          }
        }
      }
      updatePieceStacking(finalCell);
      if (killCount > 0) {
        justKilled = true;
      }
    }
  } else {
    if(oldCell) oldCell.appendChild(el);
    updatePieceStacking(oldCell);
  }

  if(isFinishing){
    p.posIndex = 'finished';
  } else {
    p.posIndex = endIndex;
  }
  p.isMoving = false;
  lastMovedPiece[p.color] = pieceId;
  if(oldCell && oldCell.id) updatePieceStacking(oldCell);
  afterMoveHandling(pieceId, gameState.diceValue);
}

function afterMoveHandling(pieceId, roll){
  const p = pieces[pieceId];
  if(!p) return;
  checkAllPiecesFinished(p.color);
  if (p.posIndex === 'finished') {
    gameState.diceValue = null;
    updateDiceAppearance();
    return;
  }
  
  if (justKilled) {
    justKilled = false;
    gameState.diceValue = null;
    updateDiceAppearance();
    return;
  }
  
  const currentPlayer = p.color;
  if (roll === 1) {
    consecutiveOnes[currentPlayer]++;
    if (consecutiveOnes[currentPlayer] === 3 && lastMovedPiece[currentPlayer]) {
      const penaltyPiece = lastMovedPiece[currentPlayer];
      setTimeout(() => {
        alert(`${currentPlayer.charAt(0).toUpperCase() + currentPlayer.slice(1)} rolled three 1's in a row! ${penaltyPiece} will be returned to home!`);
      }, 100);
      setTimeout(() => {
        returnPieceHome(penaltyPiece, true);
      }, 600);
      consecutiveOnes[currentPlayer] = 0;
      moveToNextPlayer();
      gameState.diceValue = null;
      updateDiceAppearance();
      return;
    }
  } else {
    consecutiveOnes[currentPlayer] = 0;
  }
  
  if(roll === 6) {
    if(p && p.posIndex !== 'finished') {
      gameState.diceValue = null;
      updateDiceAppearance();
      return;
    }
  }
  
  if(roll === 1 || roll === 6){
    gameState.diceValue = null;
    updateDiceAppearance();
    return;
  }
  
  moveToNextPlayer();
  gameState.diceValue = null;
  updateDiceAppearance();
}

function handlePieceSelection(pieceId){
  const p = pieces[pieceId];
  if(!p) return;
  const currentPlayer = getCurrentPlayer();
  if(p.color !== currentPlayer) return;
  if(!isTopPiece(pieceId)) return;
  if(gameState.diceValue === null) return;

  const roll = gameState.diceValue;

  if(p.posIndex === -1){
    if(roll !== 1){ return; }
    movePieceAlongPath(pieceId, 0);
    return;
  }
  
  let finalIndex = paths[p.color].length - 1;
  let newIndex = p.posIndex + roll;

  if (newIndex === finalIndex) {
    movePieceAlongPath(pieceId, 'finish');
    return;
  }

  if (newIndex > finalIndex) {
    if (roll === 6) {
      gameState.diceValue = null;
      updateDiceAppearance();
    }
    return;
  }
  
  movePieceAlongPath(pieceId, newIndex);
}

if(diceBox){
  diceBox.onclick = ()=>{
    if(gameState.diceValue !== null){ 
      return; 
    }
    const roll = weightedRoll();
    gameState.diceValue = roll;
    drawDiceFace(roll);

    setTimeout(()=>{
      const currentPlayer = getCurrentPlayer();
      const playerPieces = Object.values(pieces).filter(p=>p.color === currentPlayer);
      const movablePieces = playerPieces.filter(p=>{
        if(!isTopPiece(p.id)) return false;
        if(p.posIndex === -1 && roll === 1) return true;
        if(p.posIndex !== -1){
          const newIndex = p.posIndex + roll;
          if(newIndex === paths[p.color].length - 1) return true; 
          if(newIndex > paths[p.color].length - 1) {
            return roll === 6;
          }
          if(newIndex < paths[p.color].length) return true;
        }
        return false;
      });

      if(movablePieces.length === 0){
        const overshootPieces = playerPieces.filter(p=>{
          if(p.posIndex !== -1 && p.posIndex !== 'finished'){
            const newIndex = p.posIndex + roll;
            return newIndex > paths[p.color].length - 1 && roll === 6;
          }
          return false;
        });
        
        if(overshootPieces.length > 0 && roll === 6){
          gameState.diceValue = null;
          updateDiceAppearance();
          return;
        }
        moveToNextPlayer();
        gameState.diceValue = null;
        updateDiceAppearance();
      } else if(movablePieces.length === 1){
        handlePieceSelection(movablePieces[0].id);
      }
    }, 260);
  };
}

function moveToNextPlayer(){ 
  currentPlayerIndex = (currentPlayerIndex + 1) % players.length;
  skipInactivePlayers();
}

createSettingsPanel();
attachHoverEffect();
attachPieceListeners();
updateDiceAppearance();

const board = document.getElementById("board");
if(board){
  const obs = new MutationObserver(()=>{ setTimeout(()=>{ attachHoverEffect(); attachPieceListeners(); }, 40); });
  obs.observe(board, { childList:true, subtree:true });
}

document.addEventListener("contextmenu", event => event.preventDefault());
document.onkeydown = function(e) {
  if (e.ctrlKey && (e.key === 'c' || e.key === 'u' || e.key === 's' || e.key === 'a')) { e.preventDefault(); }
  if (e.key === 'F12') { e.preventDefault(); }
  if (e.ctrlKey && e.shiftKey && (e.key === 'I' || e.key === 'J')) { e.preventDefault(); }
};
});
</script>
</body>
</html>
