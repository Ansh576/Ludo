<html>
<head>
<title>Ludo</title>
<style>
  :root { --cell-size: 8vmin; }
  .dice {
    width: 16vmin;
    height: 16vmin;
    border: 3px solid black;
    border-radius: 15px;
    margin: -8vmin auto;
    position: relative;
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    grid-template-rows: repeat(3, 1fr);
    gap: 1vmin;
    transform: translate(1%, 1%);
    cursor: pointer;
    background: white;
    transition: background-color 0.3s ease, transform 0.2s ease;
  }
  .dot {
    width: 3vmin;
    height: 3vmin;
    background: black;
    border-radius: 50%;
    transform: translate(25%, 25%);
  }
  .main-table {
    margin: 0 auto;
    width: 100vmin;
    height: 95vmin;
  }
  table { border-collapse: collapse; table-layout: fixed; width: 100%; height: 100%; }
  table, tr, td { border: 2px solid black; text-align:center; vertical-align: middle; position: relative; overflow: hidden; }
  .shape { position:absolute; top:50%; left:50%; transform: translate(-50%,-50%); }
  .circle { width:40%; aspect-ratio: 1/1; background:white; border-radius:50%; }
  .circle1:hover, .circle2:hover, .circle3:hover, .circle4:hover { transform: translate(-50%,-50%) scale(1.3); transition: 0.1s ease; }
  .circle1 { background: blue; width: 60%; aspect-ratio:1/1; border-radius:50%; border:1px solid #000; }
  .circle2 { background: red; width: 60%; aspect-ratio:1/1; border-radius:50%; border:1px solid #000; }
  .circle3 { background: yellow; width: 60%; aspect-ratio:1/1; border-radius:50%; border:1px solid #000; }
  .circle4 { background: green; width: 60%; aspect-ratio:1/1; border-radius:50%; border:1px solid #000; }
  .star1 { color: grey; font-size: 5vmin; line-height: 1; user-select: none; }
  .star2 { color: black; font-size: 5vmin; line-height: 1; user-select: none; }
  .home-box { width:95%; height:95%; border-radius:50%; }
  #board { position: relative; }
  .piece { position: absolute; transition: transform 0.2s ease; width: min(9vmin, 8vmin); height: min(9vmin, 8vmin); border-radius: 50%; border:1px solid #000; box-sizing: border-box; }
  .piece[draggable="false"] { touch-action: manipulation; }
</style>
</head>
<body>
  <div id="board">
    <table border="1px solid black" style="width:20%;height: 20%; top: 5%; left: 3%;position: absolute;">
    <tr><td>
      <img src="C:\Users\Khadk\OneDrive\Desktop\ludo\player\blueplayer.png" style="width:100%; height:100%; object-fit: contain;user-select: none;"></td>
      <td style="width:30%;height: 50%;" id="finishblue"></td>
    </tr>
  </table>
      <table border="1px solid black" style="width:20%;height: 21%; top: 5%; right: 3%;position: absolute;">
    <tr> <td style="width:30%;height: 50%;" id="finishred"></td>
      <td>
      <img src="C:\Users\Khadk\OneDrive\Desktop\ludo\player\redplayer.png" style="width:100%; height:100%; object-fit: contain;user-select: none;"></td>
    </tr>
  </table>
      <table border="1px solid black" style="width:20%;height: 20.7%; bottom: 5%; left: 77%;position: absolute;">
    <tr><td style="width:30%;height: 50%;" id="finishgreen"></td>
      <td>
      <img src="C:\Users\Khadk\OneDrive\Desktop\ludo\player\greenplayer.png" style="width:100%; height:100%; object-fit: contain;user-select: none;"></td>
    </tr>
  </table>
      <table border="1px solid black" style="width:20.3%;height: 20.3%; bottom: 5%; right: 77%;position: absolute;">
    <tr><td>
      <img src="C:\Users\Khadk\OneDrive\Desktop\ludo\player\yellowplayer.png" style="width:100%; height:100%; object-fit: contain;user-select: none;"></td>
      <td style="width:30%;height:50%;" id="finishyellow"></td>
    </tr>
  </table>
<table class="main-table" style=>
    <tr> <td style="background-color:#ffc18c;" colspan="6" rowspan="6">
      <table class="home-box" style="border:0px;background-color: blue; border-radius: 50%;" align="center">
        <tr style="border: 0px;">
          <td style="border: 0px;">
            <div id="blue1home"  class="shape circle"> 
              <div id="blue1" class="shape circle1" onmouseover="grow(this)" ontouchstart="grow(this)" onmouseout="shrink(this)" ontouchend="shrink(this)">
              </div>
            </div>
          </td>
          <td style="border: 0px;">
            <div id="blue2home" class="shape circle"> 
              <div id="blue2" class="shape circle1" onmouseover="grow(this)" ontouchstart="grow(this)" onmouseout="shrink(this)" ontouchend="shrink(this)">
              </div>
            </div>
          </td>
        </tr>
        <tr style="border: 0px;">
          <td style="border: 0px;">
            <div id="blue3home" class="shape circle"> 
              <div id="blue3" class="shape circle1" onmouseover="grow(this)" ontouchstart="grow(this)" onmouseout="shrink(this)" ontouchend="shrink(this)">
              </div>
            </div>
          </td>
          <td style="border: 0px;">
            <div id="blue4home" class="shape circle"> 
              <div id="blue4" class="shape circle1"onmouseover="grow(this)" ontouchstart="grow(this)" onmouseout="shrink(this)" ontouchend="shrink(this)">
              </div> 
            </div>
          </td>
        </tr>
      </table>
    </td>  <td id="cell-1"></td> <td id="cell-2"></td> <td id=cell-3></td><td style="background-color:#ffc18c;" colspan="6" rowspan="6">
      <table class="home-box" style="border:0px;background-color: red; border-radius: 50%;" align="center">
        <tr style="border: 0px;">
          <td style="border: 0px;">
            <div id="red1home" class="shape circle">
              <div id="red1" class="shape circle2" onmouseover="grow(this)" ontouchstart="grow(this)" onmouseout="shrink(this)" ontouchend="shrink(this)">
              </div>
            </div>
          </td>
          <td style="border: 0px;">
            <div id="red2home" class="shape circle">
              <div id="red2" class="shape circle2" onmouseover="grow(this)" ontouchstart="grow(this)" onmouseout="shrink(this)" ontouchend="shrink(this)">
              </div>
            </div>
          </td>
        </tr>
        <tr style="border: 0px;">
          <td style="border: 0px;">
            <div id="red3home" class="shape circle">
              <div id="red3" class="shape circle2" onmouseover="grow(this)" ontouchstart="grow(this)" onmouseout="shrink(this)" ontouchend="shrink(this)">
              </div>
            </div>
          </td>
          <td style="border: 0px;">
            <div id="red4home" class="shape circle">
              <div id="red4" class="shape circle2" onmouseover="grow(this)" ontouchstart="grow(this)" onmouseout="shrink(this)" ontouchend="shrink(this)">
              </div>
            </div>
          </td>
        </tr>
      </table>
    </td></tr>
    <tr> <td id="cell-4"></td> <td id="cell-5"style="background-color: red;"></td> <td id="cell-6"style="background-color: red;"><div class="shape star1">★</div></td></tr>
    <tr> <td id="cell-7"><div class="shape star2">★</div></td> <td id="cell-8" style="background-color: red;"></td> <td id="cell-9"></td></tr>
    <tr> <td id="cell-10"></td> <td id="cell-11" style="background-color: red;"></td> <td id="cell-12"></td></tr>
    <tr> <td id="cell-13"></td> <td id="cell-14" style="background-color: red;"></td> <td id="cell-15"></td></tr>
    <tr> <td id="cell-16"></td> <td id="cell-17" style="background-color: red;"></td> <td id="cell-18"></td></tr>

    <tr> <td id="cell-19"></td> <td id="cell-20" style="background-color: blue;"><div class="shape star1">★</div></td> <td id="cell-21"></td> <td id="cell-22"></td> <td id="cell-23"></td> <td id="cell-24"></td> 
      
      <td colspan="3" rowspan="3">
        <div id="dice-box" class="dice"></div>
      </td>

      <td id="cell-25"></td> <td id="cell-26"></td> <td id="cell-27"></td> <td id="cell-28"><div class="shape star2">★</div></td> <td id="cell-29"></td> <td id="cell-30"></td></tr>
    <tr> <td id="cell-31"></td> <td id="cell-32" style="background-color: blue;"></td> <td id="cell-33" style="background-color: blue;"></td> <td id="cell-34" style="background-color: blue;"></td> <td id="cell-35" style="background-color: blue;"></td> <td id="cell-36" style="background-color: blue;"></td> <td id="cell-37" style="background-color: green;"></td> <td id="cell-38" style="background-color: green;"></td> <td id="cell-39" style="background-color: green;"></td> <td id="cell-40" style="background-color: green;"></td> <td id="cell-41" style="background-color: green;"></td> <td id="cell-42"></td></tr>
    <tr> <td id="cell-43"></td> <td id="cell-44"></td> <td id="cell-45"><div class="shape star2">★</div></td> <td id="cell-46"></td> <td id="cell-47"></td> <td id="cell-48"></td> <td id="cell-49"></td> <td id="cell-50"></td> <td id="cell-51"></td> <td id="cell-52"></td> <td id="cell-53" style="background-color: green;"><div class="shape star1">★</div></td> <td id="cell-54"></td></tr>
    <tr> <td style="background-color:#ffc18c;" colspan="6" rowspan="6">
      <table class="home-box" style="border:0px;background-color: yellow; border-radius: 50%;" align="center">
        <tr style="border: 0px;">
          <td style="border: 0px;">
            <div id="yellow1home" class="shape circle">
              <div id="yellow1" class="shape circle3" onmouseover="grow(this)" ontouchstart="grow(this)" onmouseout="shrink(this)" ontouchend="shrink(this)">
              </div>
            </div>
          </td>
          <td style="border: 0px;">
            <div id="yellow2home" class="shape circle">
              <div id="yellow2" class="shape circle3" onmouseover="grow(this)" ontouchstart="grow(this)" onmouseout="shrink(this)" ontouchend="shrink(this)">
              </div>
            </div>
          </td>
        </tr>
        <tr style="border: 0px;">
          <td style="border: 0px;">
            <div id="yellow3home" class="shape circle">
              <div id="yellow3" class="shape circle3" onmouseover="grow(this)" ontouchstart="grow(this)" onmouseout="shrink(this)" ontouchend="shrink(this)">
              </div>
            </div>
          </td>
          <td style="border: 0px;">
            <div id="yellow4home" class="shape circle">
              <div id="yellow4" class="shape circle3" onmouseover="grow(this)" ontouchstart="grow(this)" onmouseout="shrink(this)" ontouchend="shrink(this)">
              </div>
            </div>
          </td>
        </tr>
      </table></td>  <td id="cell-55"></td> <td id="cell-56" style="background-color: yellow;"></td> <td id="cell-57"></td><td style="background-color:#ffc18c;" colspan="6" rowspan="6">
        <table class="home-box" style="px;border:0px;background-color: green; border-radius: 50%;" align="center">
        <tr  style="border: 0px;">
          <td style="border: 0px;">
            <div id="green1home" class="shape circle">
              <div id="green1" class="shape circle4" onmouseover="grow(this)" ontouchstart="grow(this)" onmouseout="shrink(this)" ontouchend="shrink(this)">
              </div>
            </div>
          </td>
          <td style="border: 0px;">
            <div id="green2home" class="shape circle">
              <div id="green2" class="shape circle4" onmouseover="grow(this)" ontouchstart="grow(this)" onmouseout="shrink(this)" ontouchend="shrink(this)">
              </div>
            </div>
        </td>
        </tr>
        <tr style="border: 0px;">
          <td style="border: 0px;">
            <div id="green3home" class="shape circle">
              <div id="green3" class="shape circle4" onmouseover="grow(this)" ontouchstart="grow(this)" onmouseout="shrink(this)" ontouchend="shrink(this)">
              </div>
            </div>
          </td>
          <td style="border: 0px;">
            <div id="green4home" class="shape circle">
              <div id="green4" class="shape circle4" onmouseover="grow(this)" ontouchstart="grow(this)" onmouseout="shrink(this)" ontouchend="shrink(this)">
              </div>
            </div>
          </td>
        </tr>
      </table>
      </td></tr>
    <tr> <td id="cell-58"></td> <td id="cell-59" style="background-color: yellow;"></td> <td id="cell-60"></td></tr>
    <tr> <td id="cell-61"></td> <td id="cell-62" style="background-color: yellow;"></td> <td id="cell-63"></td></tr>
    <tr> <td id="cell-64"></td> <td id="cell-65" style="background-color: yellow;"></td> <td id="cell-66"><div class="shape star2">★</div></td></tr>
    <tr> <td id="cell-67" style="background-color: yellow;"><div class="shape star1">★</div></td> <td id="cell-68" style="background-color: yellow;"></td> <td id="cell-69"></td></tr>
    <tr> <td id="cell-70"></td> <td id="cell-71"></td> <td id="cell-72"></td></tr>
  </table>
  </div>
<script>
/* ---------- game config & state ---------- */
const players = ["blue","red","green","yellow"];
let currentPlayerIndex = 0;

const safeCells = ["cell-6","cell-7","cell-20","cell-28","cell-45","cell-53","cell-66","cell-67"];

const paths = {
  blue:  [20,21,22,23,24,16,13,10,7,4,1,2,3,6,9,12,15,18,25,26,27,28,29,30,42,54,53,52,51,50,49,57,60,63,66,69,72,71,70,67,64,61,58,55,48,47,46,45,44,43,31,32,33,34,35,36,'finishblue'],
  red:   [6,9,12,15,18,25,26,27,28,29,30,42,54,53,52,51,50,49,57,60,63,66,69,72,71,70,67,64,61,58,55,48,47,46,45,44,43,31,16,20,21,22,23,24,16,13,10,7,4,1,2,5,8,11,14,17,'finishred'],
  green: [53,52,51,50,49,57,60,63,66,69,72,71,70,67,64,61,58,55,48,47,46,45,44,43,31,19,20,21,22,23,24,16,13,10,7,4,1,2,3,6,9,12,15,18,25,26,27,28,29,30,42,41,40,39,38,37,'finishgreen'],
  yellow:[67,64,61,58,55,48,47,46,45,44,43,31,19,20,21,22,23,24,16,13,10,7,4,1,2,3,6,9,12,15,18,25,26,27,28,29,30,42,54,53,52,51,50,49,57,60,63,66,69,72,71,68,65,62,59,56,'finishyellow']
};

const pieces = {};
players.forEach(color => {
  for(let i=1;i<=4;i++){
    const id = color + i;
    pieces[id] = { id, color, posIndex: -1, isMoving: false };
  }
});

const gameState = { diceValue: null };

/* ---------- helpers ---------- */
const diceBox = document.getElementById("dice-box");
function getCurrentPlayer(){ return players[currentPlayerIndex]; }
function updateDiceAppearance(){
  const player = getCurrentPlayer();
  if(diceBox) diceBox.style.backgroundColor = player;
  if(gameState.diceValue === null){
    if(diceBox) diceBox.innerHTML = "";
  } else {
    drawDiceFace(gameState.diceValue);
  }
}
function weightedRoll(){
  const outcomes=[1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6];
  return outcomes[Math.floor(Math.random()*outcomes.length)];
}
function drawDiceFace(num){
  if(!diceBox) return;
  diceBox.innerHTML = "";
  const positions={1:[5],2:[1,9],3:[1,5,9],4:[1,3,7,9],5:[1,3,5,7,9],6:[1,3,4,6,7,9]};
  (positions[num]||[]).forEach(pos=>{
    const dot=document.createElement("div");
    dot.className="dot";
    const row=Math.ceil(pos/3);
    const col=(pos-1)%3+1;
    dot.style.gridArea = `${row} / ${col}`;
    diceBox.appendChild(dot);
  });
}

/* small sleep helper */
function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

/* await transition end (used when setting left/top transitions) */
function awaitTransition(el, timeout = 500){
  return new Promise(resolve=>{
    let done = ()=>{ el.removeEventListener('transitionend', done); resolve(); };
    let timer = setTimeout(()=>{ el.removeEventListener('transitionend', done); resolve(); }, timeout);
    el.addEventListener('transitionend', function te(e){
      // only resolve for left/top property changes
      if(e.propertyName === 'left' || e.propertyName === 'top'){
        clearTimeout(timer);
        el.removeEventListener('transitionend', te);
        resolve();
      }
    });
  });
}

/* ---------- hover effect (non-conflicting) ---------- */
function attachHoverEffect(){
  Object.keys(pieces).forEach(pid=>{
    const el = document.getElementById(pid);
    if(!el) return;

    function grow(){
      const p = pieces[pid];
      if(!p) return;
      // only allow hover grow when it's current player's piece, not moving and is top piece
      if(p.color === getCurrentPlayer() && !p.isMoving && isTopPiece(pid)){
        // apply scale while keeping center
        el.style.transition = "transform 0.18s ease";
        // store inactive translation transform separately: center is translate(-50%,-50%)
        el.style.transform = "translate(-50%,-50%) scale(1.25)";
        el.style.zIndex = 999;
      }
    }
    function shrink(){
      const p = pieces[pid];
      if(!p) return;
      // restore normal transform only if not moving
      if(!p.isMoving){
        el.style.transition = "transform 0.18s ease";
        el.style.transform = "translate(-50%,-50%) scale(1)";
        el.style.zIndex = "";
      }
    }

    // remove old listeners if re-attaching
    el.onmouseenter = null; el.onmouseleave = null;
    el.addEventListener("mouseenter", grow);
    el.addEventListener("mouseleave", shrink);
    // touch: show grow on touchstart, shrink on touchend
    el.addEventListener("touchstart", e=>{ if(pieces[pid].color===getCurrentPlayer() && !pieces[pid].isMoving && isTopPiece(pid)){ e.preventDefault(); grow(); } }, {passive:false});
    el.addEventListener("touchend", shrink);
    el.addEventListener("touchcancel", shrink);
  });
}

/* ---------- attach piece click listeners ---------- */
function attachPieceListeners(){
  Object.keys(pieces).forEach(pid=>{
    const el = document.getElementById(pid);
    if(!el) return;
    el.style.touchAction = "manipulation";
    el.addEventListener("click", ()=> handlePieceSelection(pid));
    el.addEventListener("touchstart", e=>{ e.preventDefault(); handlePieceSelection(pid); }, {passive:false});
  });
}

/* ---------- top piece check ---------- */
function isTopPiece(pieceId){
  const el = document.getElementById(pieceId);
  if(!el || !el.parentElement) return false;
  const children = Array.from(el.parentElement.children).filter(c=>c.id && pieces[c.id]);
  if(children.length === 0) return false;
  return children[children.length-1].id === pieceId;
}

/* ---------- handle piece selection ---------- */
function handlePieceSelection(pieceId){
  const p = pieces[pieceId];
  if(!p) return;
  const currentPlayer = getCurrentPlayer();
  if(p.color !== currentPlayer) return;
  if(!isTopPiece(pieceId)) return;
  if(gameState.diceValue === null) return;

  const roll = gameState.diceValue;

  if(p.posIndex === -1){
    if(roll !== 1){ alert("You can only bring piece out on 1."); return; }
    movePieceAlongPath(pieceId, 0);
    return;
  }

  let newIndex = p.posIndex + roll;
  if(newIndex >= paths[p.color].length-1 || paths[p.color][newIndex] === 'finish'){
    movePieceAlongPath(pieceId, 'finish');
    return;
  }
  movePieceAlongPath(pieceId, newIndex);
}

/* ---------- helper get cell id ---------- */
function getCellIdForPath(color,index){
  const val = paths[color][index];
  return val === 'finish' ? 'Finish' : 'cell-' + val;
}
function getPathCells(color, startIndex, endIndex){
  const path = paths[color];
  const cells = [];
  for(let i=startIndex;i<=endIndex;i++){
    cells.push(path[i] === 'finish' ? 'Finish' : 'cell-' + path[i]);
  }
  return cells;
}

/* ---------- return piece home with animation ---------- */
async function returnPieceHome(pieceId){
  const p = pieces[pieceId];
  if(!p) return;
  const el = document.getElementById(pieceId);
  if(!el) return;

  // find empty home slot
  const homeIds = [`${p.color}1home`,`${p.color}2home`,`${p.color}3home`,`${p.color}4home`];
  let targetHomeEl = null;
  for(const hid of homeIds){
    const homeEl = document.getElementById(hid);
    if(homeEl && Array.from(homeEl.children).filter(c=>c.id && pieces[c.id]).length === 0){
      targetHomeEl = homeEl;
      break;
    }
  }
  if(!targetHomeEl) targetHomeEl = document.getElementById(`${p.color}1home`);

  // guard
  if(!targetHomeEl) return;

  p.posIndex = -1;
  p.isMoving = true;

  // get board coords
  const board = document.getElementById("board");
  const rect = el.getBoundingClientRect();
  const boardRect = board.getBoundingClientRect();
  const startX = rect.left - boardRect.left + board.scrollLeft;
  const startY = rect.top - boardRect.top + board.scrollTop;

  // get target home coords (center)
  const homeRect = targetHomeEl.getBoundingClientRect();
  const targetX = homeRect.left - boardRect.left + homeRect.width/2 - rect.width/2 + board.scrollLeft;
  const targetY = homeRect.top - boardRect.top + homeRect.height/2 - rect.height/2 + board.scrollTop;

  // prepare element for absolute animation
  el.style.position = "absolute";
  el.style.left = startX + "px";
  el.style.top = startY + "px";
  el.style.width = rect.width + "px";
  el.style.height = rect.height + "px";
  el.style.transition = "left 400ms ease, top 400ms ease, transform 0.2s ease";
  board.appendChild(el);

  // animate to home
  await sleep(10);
  el.style.left = targetX + "px";
  el.style.top  = targetY + "px";

  await awaitTransition(el, 450);

  // append to home and centralize
  targetHomeEl.appendChild(el);
  el.style.position = "absolute";
  el.style.width = "";
  el.style.height = "";
  el.style.left = "50%";
  el.style.top = "50%";
  el.style.transform = "translate(-50%,-50%) scale(1)";
  el.style.transition = "";
  updatePieceStacking(targetHomeEl);

  p.isMoving = false;
}

/* ---------- update stacking ---------- */
function updatePieceStacking(cell){
  if(!cell) return;
  const pieceElements = Array.from(cell.children).filter(c=>c.id && pieces[c.id]);
  const count = pieceElements.length;
  if(count === 0) return;

  // for reliability always clear inline transition on stacking (so hover transform not overridden)
  pieceElements.forEach(el=>{ el.style.transition = ""; });

  if(count === 1){
    const el = pieceElements[0];
    el.style.position = "absolute";
    el.style.left = "50%";
    el.style.top = "50%";
    el.style.transform = "translate(-50%,-50%) scale(1)";
    el.style.zIndex = 1;
    return;
  }

  // radial layout in percentages relative to the cell center
  const radius = Math.min(8 + count*4, 30);
  pieceElements.forEach((el,index)=>{
    const angle = (index / count) * 2 * Math.PI;
    const x = 50 + radius * Math.cos(angle);
    const y = 50 + radius * Math.sin(angle);
    el.style.position = "absolute";
    el.style.left = `${x}%`;
    el.style.top = `${y}%`;
    el.style.transform = "translate(-50%,-50%) scale(1)";
    el.style.zIndex = index + 1;
  });
}

/* ---------- movement (smooth, step-by-step) ---------- */
async function movePieceAlongPath(pieceId, targetIndex){
  const p = pieces[pieceId];
  const el = document.getElementById(pieceId);
  const board = document.getElementById("board");
  if(!p || !el || !board) return;

  // guard: prevent multiple triggers
  if(p.isMoving) return;
  p.isMoving = true;

  const startIndex = p.posIndex === -1 ? -1 : p.posIndex;
  const endIndex = targetIndex === 'finish' ? paths[p.color].length-1 : targetIndex;
  const pathCells = getPathCells(p.color, startIndex + 1, endIndex);
  if(pathCells.length === 0){ p.isMoving = false; return; }

  // get sizes & start position
  const rect = el.getBoundingClientRect();
  const width = rect.width, height = rect.height;
  const boardRect = board.getBoundingClientRect();
  const startX = rect.left - boardRect.left + board.scrollLeft;
  const startY = rect.top - boardRect.top + board.scrollTop;

  // old parent (for restacking after move)
  const oldCell = el.parentElement;

  // Prepare element for absolute animation on board
  el.style.transition = "left 180ms linear, top 180ms linear";
  el.style.width = width + "px";
  el.style.height = height + "px";
  el.style.position = "absolute";
  el.style.transform = "translate(0,0)"; // don't apply translate during movement
  el.style.left = startX + "px";
  el.style.top = startY + "px";

  // move onto board (append as child to board to animate using page coords)
  board.appendChild(el);
  // small rAF to ensure browser registers starting position
  await sleep(8);

  // animate through each step cell
  for(let i=0;i<pathCells.length;i++){
    const cellId = pathCells[i];
    const cell = document.getElementById(cellId);
    if(!cell) {
      // if cell is missing, skip
      continue;
    }
    const crect = cell.getBoundingClientRect();
    // compute center position inside board coordinates
    const targetLeft = crect.left - boardRect.left + (cell.offsetWidth/2) - width/2 + board.scrollLeft;
    const targetTop  = crect.top  - boardRect.top  + (cell.offsetHeight/2) - height/2 + board.scrollTop;

    // assign new left/top to trigger CSS transition
    el.style.left = `${targetLeft}px`;
    el.style.top  = `${targetTop}px`;

    // wait for transition to end
    await awaitTransition(el, 400);
    // small pause so animation feels smooth between cells
    await sleep(30);
  }

  // arrived final cell: append it into cell and restyle to centered stacking
  const finalCell = (targetIndex === 'finish') ? document.getElementById('Finish') : document.getElementById(getCellIdForPath(p.color, endIndex));
  if(finalCell){
    finalCell.appendChild(el);
    // remove the explicit left/top/width/height and restore centering by transform
    el.style.position = "absolute";
    el.style.width = "";
    el.style.height = "";
    el.style.left = "50%";
    el.style.top = "50%";
    el.style.transform = "translate(-50%,-50%)";
    el.style.transition = ""; // clear transition to avoid affecting stacking transform
    // after DOM reflow, update stacking
    updatePieceStacking(finalCell);

    // handle kills (only if not a safe cell)
    if(!safeCells.includes(finalCell.id)){
      // copy children because returnPieceHome mutates DOM
      const children = Array.from(finalCell.children).filter(c=>c.id && pieces[c.id]);
      for(const child of children){
        if(child.id !== pieceId && pieces[child.id] && pieces[child.id].color !== p.color){
          // return the opponent piece home
          returnPieceHome(child.id);
        }
      }
      // centralize/stack again after kills
      updatePieceStacking(finalCell);
    }
  } else {
    // fallback: append back to old parent
    if(oldCell) oldCell.appendChild(el);
    updatePieceStacking(oldCell);
  }

  // update posIndex and state
  p.posIndex = (targetIndex === 'finish') ? 'finished' : endIndex;
  p.isMoving = false;

  // ensure old cell stacking updated
  if(oldCell && oldCell.id) updatePieceStacking(oldCell);

  // after-move handling: change turn or allow extra roll
  afterMoveHandling(pieceId, gameState.diceValue);
}

/* ---------- after move ---------- */
function afterMoveHandling(pieceId, roll){
  // if roll is 1 or 6, player gets another chance (common Ludo rule in your code)
  if(roll === 1 || roll === 6){
    gameState.diceValue = null;
    updateDiceAppearance();
    // keep same player -> do nothing to currentPlayerIndex
    return;
  }
  // otherwise next player
  moveToNextPlayer();
  gameState.diceValue = null;
  updateDiceAppearance();
}

/* ---------- dice click ---------- */
if(diceBox){
  diceBox.onclick = ()=>{
    if(gameState.diceValue !== null){ console.log("Move a piece first."); return; }
    const roll = weightedRoll();
    gameState.diceValue = roll;
    drawDiceFace(roll);

    // small delay then auto-move if only one choice exists
    setTimeout(()=>{
      const currentPlayer = getCurrentPlayer();
      const playerPieces = Object.values(pieces).filter(p=>p.color === currentPlayer);
      const movablePieces = playerPieces.filter(p=>{
        if(!isTopPiece(p.id)) return false;
        if(p.posIndex === -1 && roll === 1) return true;
        if(p.posIndex !== -1 && p.posIndex + roll < paths[p.color].length) return true;
        return false;
      });

      if(movablePieces.length === 0){
        moveToNextPlayer();
        gameState.diceValue = null;
        updateDiceAppearance();
      } else if(movablePieces.length === 1){
        handlePieceSelection(movablePieces[0].id);
      }
    }, 260);
  };
}

/* ---------- next player ---------- */
function moveToNextPlayer(){ currentPlayerIndex = (currentPlayerIndex + 1) % players.length; }

/* ---------- initial attach ---------- */
attachHoverEffect();
attachPieceListeners();
updateDiceAppearance();

/* ---------- Re-attach hover listeners after any DOM moves (safe) ---------- */
/* We can observe the board for childList changes (pieces moving) and reattach hover listeners after small delay */
const board = document.getElementById("board");
if(board){
  const obs = new MutationObserver(()=>{ setTimeout(()=>{ attachHoverEffect(); attachPieceListeners(); }, 40); });
  obs.observe(board, { childList:true, subtree:true });
}
</script>
<script>
  document.addEventListener("contextmenu", event => event.preventDefault());

  document.onkeydown = function(e) {
        if (e.ctrlKey && 
           (e.key === 'c' || e.key === 'u' || e.key === 's' || e.key === 'a')) {
            e.preventDefault();
        }
        if (e.key === 'F12') {
            e.preventDefault();
        }
        if (e.ctrlKey && e.shiftKey && (e.key === 'I' || e.key === 'J')) {
            e.preventDefault();
        }
    };
</script>
</body>
</html>